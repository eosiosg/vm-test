#include <eosio/vm/backend.hpp>
#include <eosio/vm/error_codes.hpp>
#include <eosio/vm/host_function.hpp>
#include <eosio/vm/watchdog.hpp>
#include <exception>
#include <iostream>

namespace eosio { namespace vm {
template <>
struct wasm_type_converter<const char *> : linear_memory_access {
  const char *from_wasm(const void *val) {
    validate_c_str(val);
    return static_cast<const char *>(val);
  }
};
}}
// example of host function as a raw C style function
void eosio_assert(bool test, const char *msg) {
  if (!test) {
    std::cout << msg << std::endl;
    throw 0;
  }
}

void print_num(uint64_t n) { std::cout << "Number : " << n << "\n"; }

struct example_host_methods {
  // example of a host "method"
  void print_name(const char *nm) {
    std::cout << "Name : " << nm << " " << field << "\n";
  }
  // example of another type of host function
  static void *memset(void *ptr, int x, size_t n) {
    return ::memset(ptr, x, n);
  }
  std::string field = "";
};

void test() {
  std::vector<uint8_t> hello_wasm = {
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x1e, 0x06, 0x60,
      0x01, 0x7e, 0x00, 0x60, 0x02, 0x7f, 0x7f, 0x00, 0x60, 0x01, 0x7f, 0x00,
      0x60, 0x03, 0x7f, 0x7f, 0x7f, 0x01, 0x7f, 0x60, 0x00, 0x00, 0x60, 0x03,
      0x7e, 0x7e, 0x7e, 0x00, 0x02, 0x42, 0x04, 0x03, 0x65, 0x6e, 0x76, 0x09,
      0x70, 0x72, 0x69, 0x6e, 0x74, 0x5f, 0x6e, 0x75, 0x6d, 0x00, 0x00, 0x03,
      0x65, 0x6e, 0x76, 0x0c, 0x65, 0x6f, 0x73, 0x69, 0x6f, 0x5f, 0x61, 0x73,
      0x73, 0x65, 0x72, 0x74, 0x00, 0x01, 0x03, 0x65, 0x6e, 0x76, 0x0a, 0x70,
      0x72, 0x69, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x02, 0x03,
      0x65, 0x6e, 0x76, 0x06, 0x6d, 0x65, 0x6d, 0x73, 0x65, 0x74, 0x00, 0x03,
      0x03, 0x05, 0x04, 0x04, 0x04, 0x02, 0x05, 0x04, 0x05, 0x01, 0x70, 0x01,
      0x01, 0x01, 0x05, 0x03, 0x01, 0x00, 0x01, 0x06, 0x16, 0x03, 0x7f, 0x01,
      0x41, 0x80, 0xc0, 0x00, 0x0b, 0x7f, 0x00, 0x41, 0xa6, 0xc0, 0x00, 0x0b,
      0x7f, 0x00, 0x41, 0xa6, 0xc0, 0x00, 0x0b, 0x07, 0x09, 0x01, 0x05, 0x61,
      0x70, 0x70, 0x6c, 0x79, 0x00, 0x07, 0x0a, 0x83, 0x01, 0x04, 0x04, 0x00,
      0x10, 0x05, 0x0b, 0x36, 0x01, 0x01, 0x7f, 0x23, 0x00, 0x41, 0x10, 0x6b,
      0x22, 0x00, 0x41, 0x00, 0x36, 0x02, 0x0c, 0x41, 0x00, 0x20, 0x00, 0x28,
      0x02, 0x0c, 0x28, 0x02, 0x00, 0x41, 0x07, 0x6a, 0x41, 0x78, 0x71, 0x22,
      0x00, 0x36, 0x02, 0x84, 0x40, 0x41, 0x00, 0x20, 0x00, 0x36, 0x02, 0x80,
      0x40, 0x41, 0x00, 0x3f, 0x00, 0x36, 0x02, 0x8c, 0x40, 0x0b, 0x02, 0x00,
      0x0b, 0x42, 0x00, 0x10, 0x04, 0x20, 0x00, 0x10, 0x00, 0x20, 0x01, 0x10,
      0x00, 0x20, 0x02, 0x10, 0x00, 0x02, 0x40, 0x20, 0x01, 0x20, 0x02, 0x51,
      0x0d, 0x00, 0x41, 0x00, 0x41, 0x90, 0xc0, 0x00, 0x10, 0x01, 0x0b, 0x02,
      0x40, 0x20, 0x00, 0x50, 0x0d, 0x00, 0x03, 0x40, 0x41, 0x9f, 0xc0, 0x00,
      0x10, 0x02, 0x20, 0x00, 0x42, 0x7f, 0x7c, 0x22, 0x00, 0x50, 0x45, 0x0d,
      0x00, 0x0b, 0x0b, 0x41, 0x00, 0x10, 0x06, 0x0b, 0x0b, 0x2e, 0x03, 0x00,
      0x41, 0x90, 0xc0, 0x00, 0x0b, 0x0f, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72,
      0x65, 0x20, 0x42, 0x20, 0x21, 0x3d, 0x20, 0x43, 0x00, 0x00, 0x41, 0x9f,
      0xc0, 0x00, 0x0b, 0x07, 0x65, 0x6f, 0x73, 0x2d, 0x76, 0x6d, 0x00, 0x00,
      0x41, 0x00, 0x0b, 0x04, 0x28, 0x20, 0x00, 0x00};
  // Thread specific `allocator` used for wasm linear memory.
  using eosio::vm::wasm_allocator;
  using eosio::vm::watchdog;
  wasm_allocator wa;
  // Specific the backend with example_host_methods for host functions.
  using backend_t = eosio::vm::backend<example_host_methods>;
  using rhf_t = eosio::vm::registered_host_functions<example_host_methods>;

  // register print_num
  rhf_t::add<nullptr_t, &print_num, wasm_allocator>("env", "print_num");
  // register eosio_assert
  rhf_t::add<nullptr_t, &eosio_assert, wasm_allocator>("env", "eosio_assert");
  // register print_name
  rhf_t::add<example_host_methods, &example_host_methods::print_name,
             wasm_allocator>("env", "print_name");
  // finally register memset
  rhf_t::add<nullptr_t, &example_host_methods::memset, wasm_allocator>(
      "env", "memset");

  watchdog wd{std::chrono::seconds(3)};
  try {
    // Instaniate a new backend using the wasm provided.
    backend_t bkend(hello_wasm, rhf_t{});

    // Point the backend to the allocator you want it to use.
    bkend.set_wasm_allocator(&wa);
    bkend.initialize();
    // Resolve the host functions indices.

    // Instaniate a "host"
    example_host_methods ehm;
    ehm.field = "testing";
    // Execute apply.
    uint64_t a = 3;
    uint64_t b = 4;
    uint64_t c = 4;
    bkend(&ehm, "env", "apply", a, b, c);

  } catch (std::exception &e) {
    std::cerr << e.what() << std::endl;
  }
}

int main() {
  std::cout << "Hello, World!" << std::endl;
  test();
  return 0;
}